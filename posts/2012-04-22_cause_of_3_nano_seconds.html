<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>8c6794b6.github.com - Cause of 3 nano seconds difference</title>
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
    <link rel="icon" href="favicon.ico" type="image/ico">
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <link rel="stylesheet" type="text/css" href="../css/hk-tango.css">
    <link rel="alternate" type="application/rss+xml" title="8c6794b6" href="../rss.xml">
  </head>
  <body>
    <div>
      <div id="header">
        <div id="header_contents">
          <div id="header_left">
            <a href="../">8c6794b6.github.com</a>
          </div>
          <div id="navigation">
            <a href="../index.html">Home</a>
            <a href="../archive.html">Archive</a>
            <a href="../rss.xml">RSS</a>
          </div>
        </div>
      </div>

      <div id="content">

        <h1>Cause of 3 nano seconds difference</h1>
<div id="post_date">
  <strong>April 22, 2012</strong>
</div>

<div id="post_body">
<p><code>Unboxed Vector</code>, in <a href="http://hackage.haskell.org/package/vector">vector</a> package is efficient data structure. Iterating over unboxed value is pretty fast.</p>
<p>Is there any faster way to iterate than unboxed vector?</p>
<p>Interest of comparision here is <em>efficiency of iteration</em>. Not the body contents of work in each iteration, but overhead we get from the loop.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE BangPatterns #-}</span>
<span class="fu">&gt;</span> <span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Criterion.Main</span> (bench, defaultMain, nf)
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector.Unboxed</span> <span class="kw">as</span> <span class="dt">U</span></code></pre>
<p>Couple type synonyms, and body function to apply inside the loop.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">type</span> <span class="dt">Updater</span> a <span class="fu">=</span> a <span class="ot">-&gt;</span> a
<span class="fu">&gt;</span> <span class="kw">type</span> <span class="dt">Work</span> a <span class="fu">=</span> <span class="dt">Updater</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span><span class="ot"> add1 ::</span> <span class="dt">Updater</span> <span class="dt">Int</span>
<span class="fu">&gt;</span> add1 <span class="fu">=</span> (<span class="fu">+</span><span class="dv">1</span>)</code></pre>
<p>Using unboxed vector to loop for given time. Using <code>foldl'</code> and <code>replicate</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> work01 ::</span> <span class="dt">Work</span> <span class="dt">Int</span>
<span class="fu">&gt;</span> work01 f n m <span class="fu">=</span> U.foldl' (\x _ <span class="ot">-&gt;</span> f x) n (U.replicate m ())</code></pre>
<p>Invoking <code>work01</code> with <code>add1</code>. Below will apply <code>add1</code> to 0 for 100 times.</p>
<pre><code>ghci&gt; work01 add1 0 100
100</code></pre>
<p>Manual recursive loop function with wrapper strict data type.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">P</span> <span class="fu">=</span> <span class="dt">P</span> <span class="ot">{-# UNPACK #-} !Int {-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span>
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span><span class="ot"> work02 ::</span> <span class="dt">Work</span> <span class="dt">Int</span>
<span class="fu">&gt;</span> work02 f n0 m <span class="fu">=</span> go (<span class="dt">P</span> <span class="dv">0</span> n0) <span class="kw">where</span>
<span class="fu">&gt;</span>   <span class="ot">{-# INLINE go #-}</span>
<span class="fu">&gt;</span>   go <span class="fu">!</span>(<span class="dt">P</span> i n) <span class="fu">|</span> i <span class="fu">==</span> m    <span class="fu">=</span> n
<span class="fu">&gt;</span>               <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> go (<span class="dt">P</span> (i<span class="dv">+1</span>) (f n))</code></pre>
<p>Again, applying <code>add1</code> to 0 for 100 times.</p>
<pre><code>ghci&gt; work02 add1 0 100
100</code></pre>
<p>Main for taking benchmark looks like below.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> main_one ::</span> <span class="dt">IO</span> ()
<span class="fu">&gt;</span> main_one <span class="fu">=</span> <span class="kw">do</span>
<span class="fu">&gt;</span>   <span class="kw">let</span> k <span class="fu">=</span> <span class="dv">2</span> <span class="fu">^</span> <span class="dv">10</span>
<span class="fu">&gt;</span>   defaultMain
<span class="fu">&gt;</span>     [ bench <span class="st">&quot;unboxed vector&quot;</span> (nf (work01 add1 <span class="dv">0</span>) k)
<span class="fu">&gt;</span>     , bench <span class="st">&quot;hand written recursion&quot;</span> (nf (work02 add1 <span class="dv">0</span>) k)
<span class="fu">&gt;</span>     ]</code></pre>
<p>Compiling with couple optimization options:</p>
<pre><code>$ ghc -O3 -fllvm -optl-O3 -main-is main_one -o a.out loop.lhs</code></pre>
<p>The benchmark result:</p>
<pre><code>benchmarking unboxed vector
mean: 52.56010 ns, lb 52.49446 ns, ub 52.64269 ns, ci 0.950
std dev: 376.4229 ps, lb 310.1393 ps, ub 458.0804 ps, ci 0.950

benchmarking hand written recursion
mean: 55.53802 ns, lb 55.51631 ns, ub 55.56074 ns, ci 0.950
std dev: 113.1906 ps, lb 103.0162 ps, ub 125.4034 ps, ci 0.950</code></pre>
<p>In this micro benchmark, looping with unboxed vector was about 3 nano seconds faster than manual strict recursion.</p>
<p>What is the cause of this 3 nano seconds difference? Seems like it’s a goot time to have a look at GHC core. Dumped core of <code>work01</code> looks like below:</p>
<pre><code>Main.work01 :: Main.Work GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=DmdType LS(A)U(L)m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=0, Value=True,
         ConLike=True, Cheap=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)
         Tmpl= Main.work1
               `cast` (&lt;Main.Updater GHC.Types.Int&gt;
                       -&gt; &lt;GHC.Types.Int&gt;
                       -&gt; &lt;GHC.Types.Int&gt;
                       -&gt; Data.Vector.Fusion.Util.NTCo:Id &lt;GHC.Types.Int&gt;
                       :: (Main.Updater GHC.Types.Int
                           -&gt; GHC.Types.Int
                           -&gt; GHC.Types.Int
                           -&gt; Data.Vector.Fusion.Util.Id GHC.Types.Int)
                            ~#
                          (Main.Updater GHC.Types.Int
                           -&gt; GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int))}]
Main.work01 =
  Main.work1
  `cast` (&lt;Main.Updater GHC.Types.Int&gt;
          -&gt; &lt;GHC.Types.Int&gt;
          -&gt; &lt;GHC.Types.Int&gt;
          -&gt; Data.Vector.Fusion.Util.NTCo:Id &lt;GHC.Types.Int&gt;
          :: (Main.Updater GHC.Types.Int
              -&gt; GHC.Types.Int
              -&gt; GHC.Types.Int
              -&gt; Data.Vector.Fusion.Util.Id GHC.Types.Int)
               ~#
             (Main.Updater GHC.Types.Int
              -&gt; GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int))</code></pre>
<p>We don’t find the actual work in <code>Main.work01</code> from dumped result. It’s function body shows that <code>work01</code> is calling <code>cast</code> with <code>Main.work1</code>, which should doing the actual work.</p>
<p>The dumped core of <code>work02</code> looks like this</p>
<pre><code>Main.work02 [InlPrag=INLINE[0]] :: Main.Work GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=DmdType LU(L)U(L)m,
 Unf=Unf{Src=Worker=Main.$wwork02, TopLvl=True, Arity=3, Value=True,
         ConLike=True, Cheap=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2Uw [Occ=Once] :: Main.Updater GHC.Types.Int)
                 (w1_s2Ux [Occ=Once!] :: GHC.Types.Int)
                 (w2_s2UB [Occ=Once!] :: GHC.Types.Int) -&gt;
                 case w1_s2Ux of _ { GHC.Types.I# ww_s2Uz [Occ=Once] -&gt;
                 case w2_s2UB of _ { GHC.Types.I# ww1_s2UD [Occ=Once] -&gt;
                 case Main.$wwork02 w_s2Uw ww_s2Uz ww1_s2UD
                 of ww2_s2UH { __DEFAULT -&gt;
                 GHC.Types.I# ww2_s2UH
                 }
                 }
                 }}]
Main.work02 =
  \ (w_s2Uw :: Main.Updater GHC.Types.Int)
    (w1_s2Ux :: GHC.Types.Int)
    (w2_s2UB :: GHC.Types.Int) -&gt;
    case w1_s2Ux of _ { GHC.Types.I# ww_s2Uz -&gt;
    case w2_s2UB of _ { GHC.Types.I# ww1_s2UD -&gt;
    case Main.$wwork02 w_s2Uw ww_s2Uz ww1_s2UD
    of ww2_s2UH { __DEFAULT -&gt;
    GHC.Types.I# ww2_s2UH
    }
    }
    }

Main.$wwork02
  :: Main.Updater GHC.Types.Int
     -&gt; GHC.Prim.Int# -&gt; GHC.Prim.Int# -&gt; GHC.Prim.Int#
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=DmdType LLL,
 Unf=Unf{Src=&lt;vanilla&gt;, TopLvl=True, Arity=3, Value=True,
         ConLike=True, Cheap=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 152 0}]
Main.$wwork02 =
  \ (w_s2VX :: Main.Updater GHC.Types.Int)
    (ww_s2W0 :: GHC.Prim.Int#)
    (ww1_s2W4 :: GHC.Prim.Int#) -&gt;
    letrec {
      $wgo1_s2Xg [Occ=LoopBreaker]
        :: GHC.Prim.Int# -&gt; GHC.Prim.Int# -&gt; GHC.Prim.Int#
      [LclId, Arity=2, Str=DmdType LL]
      $wgo1_s2Xg =
        \ (ww2_s2VN :: GHC.Prim.Int#) (ww3_s2VO :: GHC.Prim.Int#) -&gt;
          case GHC.Prim.==# ww2_s2VN ww1_s2W4 of _ {
            GHC.Types.False -&gt;
              case w_s2VX (GHC.Types.I# ww3_s2VO) of _ { GHC.Types.I# tpl1_B6 -&gt;
              $wgo1_s2Xg (GHC.Prim.+# ww2_s2VN 1) tpl1_B6
              };
            GHC.Types.True -&gt; ww3_s2VO
          }; } in
    $wgo1_s2Xg 0 ww_s2W0</code></pre>
<p>After taking a closer look, I realised that <code>i == m</code> in guard of <code>work02</code> is carrying <code>m</code>, which is passed through the inner functions found in the core. This lead <code>$wwork02</code> to compare <code>ww2_s2VN</code> and <code>ww1_s2w4</code>, which both of them passed from argument in <code>work02</code>.</p>
<p>Rewriting the guard to compare with constant <code>0</code> instead of <code>m</code>:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> work03 ::</span> <span class="dt">Work</span> <span class="dt">Int</span>
<span class="fu">&gt;</span> work03 f n0 m <span class="fu">=</span> go (<span class="dt">P</span> m n0) <span class="kw">where</span>
<span class="fu">&gt;</span>   <span class="ot">{-# INLINE go #-}</span>
<span class="fu">&gt;</span>   go <span class="fu">!</span>(<span class="dt">P</span> i n) <span class="fu">|</span> i <span class="fu">==</span> <span class="dv">0</span>    <span class="fu">=</span> n
<span class="fu">&gt;</span>               <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> go (<span class="dt">P</span> (i<span class="dv">-1</span>) (f n))</code></pre>
<p>New main for taking benchmark:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> main_two ::</span> <span class="dt">IO</span> ()
<span class="fu">&gt;</span> main_two <span class="fu">=</span> <span class="kw">do</span>
<span class="fu">&gt;</span>   <span class="kw">let</span> k <span class="fu">=</span> <span class="dv">2</span> <span class="fu">^</span> <span class="dv">10</span>
<span class="fu">&gt;</span>   defaultMain
<span class="fu">&gt;</span>     [ bench <span class="st">&quot;unboxed vector&quot;</span> (nf (work01 add1 <span class="dv">0</span>) k)
<span class="fu">&gt;</span>     , bench <span class="st">&quot;hand written recursion, take 2&quot;</span> (nf (work03 add1 <span class="dv">0</span>) k)
<span class="fu">&gt;</span>     ]</code></pre>
<p>Compiling:</p>
<pre><code>$ ghc -O3 -fllvm -optl-O3 -main-is main_two -o b.out loop.lhs</code></pre>
<p>And running the benchmark:</p>
<pre><code>benchmarking unboxed vector
mean: 49.86483 ns, lb 49.84522 ns, ub 49.88565 ns, ci 0.950
std dev: 103.5967 ps, lb 91.78539 ps, ub 117.8307 ps, ci 0.950

benchmarking hand written recursion, take 2
mean: 48.45895 ns, lb 48.37886 ns, ub 48.61787 ns, ci 0.950
std dev: 554.6886 ps, lb 337.5092 ps, ub 946.0307 ps, ci 0.950</code></pre>
<p>Now the hand written recursion performs about 1.4 nano second faster than unboxed vector. Whenever possible, compare with constant in guards. And, if few nano seconds does not matter, just use unboxed vector.</p>
</div>

<div class="post_tags">
  <strong>Tags: </strong><a href="../tags/haskell.html">haskell</a>, <a href="../tags/performance.html">performance</a>
</div>


      </div>
      <div id="footer">
        <div id="footer_content">
          <p>
            <a href="../index.html">Home</a> |
            <a href="../archive.html">Archive</a> |
            <a href="../rss.xml">RSS</a>
          </p>

          Site contents licensed under
          <a href="http://creativecommons.org/licenses/by/3.0/">
            CC Attribution 3.0
          </a>
        </div>
      </div>
    </div>
  </body>
</html>
