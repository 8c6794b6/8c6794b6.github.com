<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>8c6794b6.github.io - Benchmarking insert and member with AVL tree</title>
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
    <link rel="icon" href="favicon.ico" type="image/ico">
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <link rel="stylesheet" type="text/css" href="../css/hk-tango.css">
    <link rel="alternate" type="application/rss+xml" title="8c6794b6" href="../rss.xml">
  </head>
  <body>
    <div>
      <div id="header">
        <div id="header_contents">
          <div id="header_left">
            <a href="../">8c6794b6.github.io</a>
          </div>
          <div id="navigation">
            <a href="../index.html">Home</a>
            <a href="../archive.html">Archive</a>
            <a href="../rss.xml">RSS</a>
          </div>
        </div>
      </div>
      <div id="content">
        <h1>Benchmarking insert and member with AVL tree</h1>
<div id="post_date">
  <strong>December 17, 2012</strong>
</div>
<div class="post_tags">
  <strong>Tags: </strong><a href="../tags/haskell.html">haskell</a>, <a href="../tags/tree.html">tree</a>, <a href="../tags/datastructure.html">datastructure</a>, <a href="../tags/algorithm.html">algorithm</a>
</div>

<div id="post_body">
<p>While I was reading <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL Tree</a> page on wikipedia, it motivated me enough to write the implementation in Haskell.</p>
<p>There are couple AVL Tree implementations already exist: <a href="http://hackage.haskell.org/package/AvlTree">a package uploaded to hackage</a>, <a href="https://gist.github.com/109729">gist snippet</a>, and <a href="http://www.okmij.org/ftp/Haskell/types.html#stanamic-AVL">polymorphic stanamically balanced AVL tree</a>. As for classic data structure and algorithm exercise, decided to write a simple implementation.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE BangPatterns #-}</span>
<span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">AVL</span> <span class="kw">where</span></code></pre>
<p>For taking benchmarks and comparison with <code>Data.Map</code> from container package. None of these modules are used in code implementing AVL.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span> Control.DeepSeq (NFData(..), deepseq)
<span class="ot">&gt;</span> <span class="kw">import</span> Criterion.Main
<span class="ot">&gt;</span> <span class="kw">import</span> System.Random
<span class="ot">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> Data.Map <span class="kw">as</span> M</code></pre>
<p>Like other binary trees, AVL tree has leaf constructor and node constructor with right and left branch, with a field to hold height of the node:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">AVL</span> a
<span class="ot">&gt;</span>   <span class="fu">=</span> <span class="dt">Node</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span> <span class="fu">!</span>(<span class="dt">AVL</span> a) <span class="fu">!</span>a <span class="fu">!</span>(<span class="dt">AVL</span> a)
<span class="ot">&gt;</span>   <span class="fu">|</span> <span class="dt">Leaf</span>
<span class="ot">&gt;</span>   <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre>
<p>There was a note about order of constructors written in comments of <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Map-Base.html">Data.Map.Base</a>:</p>
<pre><code>When type has 2 constructors, a forward conditional jump is made
when successfully matching second constructor, in GHC 7.0.</code></pre>
<p>This was still true in GHC 7.6.1, the version used at the time of writing. This is the reason why <code>Node</code> constructor came before the <code>Leaf</code> constructor.</p>
<p>An alias for leaf node:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; empty ::</span> <span class="dt">AVL</span> a
<span class="ot">&gt;</span> empty <span class="fu">=</span> <span class="dt">Leaf</span>
<span class="ot">&gt;</span> <span class="ot">{-# INLINEABLE empty #-}</span></code></pre>
<p>Height of tree. Defining height of <code>Leaf</code> node as ‘0’.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; height ::</span> <span class="dt">AVL</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> height t <span class="fu">=</span> <span class="kw">case</span> t <span class="kw">of</span>
<span class="ot">&gt;</span>   <span class="dt">Leaf</span>          <span class="ot">-&gt;</span> <span class="dv">0</span>
<span class="ot">&gt;</span>   <span class="dt">Node</span> <span class="fu">!</span>n _ _ _ <span class="ot">-&gt;</span> n
<span class="ot">&gt;</span> <span class="ot">{-# INLINE height #-}</span></code></pre>
<p>Insert element to AVL tree. This function calls <code>rebalance</code> after inserting new element. Also, new element is strictly evaluated inside the local function <code>go</code>.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">AVL</span> a <span class="ot">-&gt;</span> <span class="dt">AVL</span> a
<span class="ot">&gt;</span> insert <span class="fu">=</span> go <span class="kw">where</span>
<span class="ot">&gt;   go ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">AVL</span> a <span class="ot">-&gt;</span> <span class="dt">AVL</span> a
<span class="ot">&gt;</span>   go <span class="fu">!</span>n <span class="dt">Leaf</span>             <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">1</span> <span class="dt">Leaf</span> n <span class="dt">Leaf</span>
<span class="ot">&gt;</span>   go <span class="fu">!</span>n (<span class="dt">Node</span> h l <span class="fu">!</span>n' r) <span class="fu">=</span> <span class="kw">case</span> compare n' n <span class="kw">of</span>
<span class="ot">&gt;</span>     <span class="dt">LT</span> <span class="ot">-&gt;</span> rebalance <span class="fu">$</span> <span class="dt">Node</span> h l n' (insert n r)
<span class="ot">&gt;</span>     _  <span class="ot">-&gt;</span> rebalance <span class="fu">$</span> <span class="dt">Node</span> h (insert n l) n' r
<span class="ot">&gt;</span> <span class="ot">{-# INLINEABLE insert #-}</span></code></pre>
<p>A function to check whether given element is a member of tree or not. Given element and element of pattern matched node are, again strictly evaluated.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; member ::</span> (<span class="dt">Ord</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">AVL</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> member _  <span class="dt">Leaf</span>           <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span> member <span class="fu">!</span>x (<span class="dt">Node</span> _ l <span class="fu">!</span>y r) <span class="fu">=</span> <span class="kw">case</span> compare x y <span class="kw">of</span>
<span class="ot">&gt;</span>   <span class="dt">LT</span> <span class="ot">-&gt;</span> member x l
<span class="ot">&gt;</span>   <span class="dt">GT</span> <span class="ot">-&gt;</span> member x r
<span class="ot">&gt;</span>   <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">True</span>
<span class="ot">&gt;</span> <span class="ot">{-# INLINEABLE member #-}</span></code></pre>
<p>There could be more functions, delete, merge, etc. But I’m little bit lazy to write them in this post.</p>
<p>Here comes the balancing function. It rebalances tree, four cases are considered: <em>right-right</em>, <em>right-left</em>, <em>left-left</em>, and <em>left-right</em>.</p>
<p>Firstly, comparing with <code>Leaf</code> node, which is not needed to rebalance any more. Then the height from left node and right node are compared, leading to next case.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; rebalance ::</span> <span class="dt">AVL</span> a <span class="ot">-&gt;</span> <span class="dt">AVL</span> a
<span class="ot">&gt;</span> rebalance <span class="dt">Leaf</span>                 <span class="fu">=</span> <span class="dt">Leaf</span>
<span class="ot">&gt;</span> rebalance n1<span class="fu">@</span>(<span class="dt">Node</span> _ l1 x1 r1) <span class="fu">=</span> <span class="kw">case</span> compare hL1 hR1 <span class="kw">of</span>
<span class="ot">&gt;</span>   <span class="dt">LT</span> <span class="ot">-&gt;</span> rightIsHeavy
<span class="ot">&gt;</span>   <span class="dt">GT</span> <span class="ot">-&gt;</span> leftIsHeavy
<span class="ot">&gt;</span>   <span class="dt">EQ</span> <span class="ot">-&gt;</span> updateHeight n1
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;</span>     hL1 <span class="fu">=</span> height l1
<span class="ot">&gt;</span>     hR1 <span class="fu">=</span> height r1</code></pre>
<p>When right node is heavy, we compare the left node and right node again, and perform the rotations.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     rightIsHeavy <span class="fu">=</span> <span class="kw">case</span> r1 <span class="kw">of</span>
<span class="ot">&gt;</span>       <span class="dt">Leaf</span>            <span class="ot">-&gt;</span> n1
<span class="ot">&gt;</span>       <span class="dt">Node</span> _ l2 x2 r2 <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>         <span class="kw">case</span> compare (height l2) (height r2) <span class="kw">of</span></code></pre>
<p>The right-right case, single rotation swapping the node in the middle to top and top node to left:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>           <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> (hL1<span class="fu">+</span><span class="dv">2</span>) (<span class="dt">Node</span> (hL1<span class="fu">+</span><span class="dv">1</span>) l1 x1 l2) x2 r2</code></pre>
<p>The right-left case, bringing the bottom element to top, top element to left, and middle element to right, with reordering each hanging nodes appropriately.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>           <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="kw">case</span> l2 <span class="kw">of</span>
<span class="ot">&gt;</span>             <span class="dt">Leaf</span>             <span class="ot">-&gt;</span> n1
<span class="ot">&gt;</span>             <span class="dt">Node</span> h3 l3 x3 r3 <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>               <span class="dt">Node</span> (h3<span class="fu">+</span><span class="dv">1</span>) (<span class="dt">Node</span> h3 l1 x1 l3) x3 (<span class="dt">Node</span> h3 r3 x2 r2)</code></pre>
<p>Nothing left to do when nodes already has same height, merely returning the given node itself.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>           <span class="dt">EQ</span> <span class="ot">-&gt;</span> n1</code></pre>
<p>Left-left case and left-right cases are symmetrical to above:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     leftIsHeavy <span class="fu">=</span> <span class="kw">case</span> l1 <span class="kw">of</span>
<span class="ot">&gt;</span>       <span class="dt">Leaf</span>            <span class="ot">-&gt;</span> n1
<span class="ot">&gt;</span>       <span class="dt">Node</span> _ l2 x2 r2 <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>         <span class="kw">case</span> compare (height l2) (height r2) <span class="kw">of</span>
<span class="ot">&gt;</span>           <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="kw">case</span> r2 <span class="kw">of</span>
<span class="ot">&gt;</span>             <span class="dt">Leaf</span>             <span class="ot">-&gt;</span> n1
<span class="ot">&gt;</span>             <span class="dt">Node</span> h3 l3 x3 r3 <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>               <span class="dt">Node</span> (h3<span class="fu">+</span><span class="dv">1</span>) (<span class="dt">Node</span> h3 l2 x2 l3) x3 (<span class="dt">Node</span> h3 r3 x1 r1)
<span class="ot">&gt;</span>           <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> (hR1<span class="fu">+</span><span class="dv">2</span>) l2 x2 (<span class="dt">Node</span> (hR1<span class="fu">+</span><span class="dv">1</span>) r2 x1 r1)
<span class="ot">&gt;</span>           <span class="dt">EQ</span> <span class="ot">-&gt;</span> n1
<span class="ot">&gt;</span> <span class="ot">{-# INLINE rebalance #-}</span></code></pre>
<p>Non-recursive height updating function, used in <code>EQ</code> case of <code>rebalance</code>:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; updateHeight ::</span> <span class="dt">AVL</span> a <span class="ot">-&gt;</span> <span class="dt">AVL</span> a
<span class="ot">&gt;</span> updateHeight t <span class="fu">=</span> <span class="kw">case</span> t <span class="kw">of</span>
<span class="ot">&gt;</span>   <span class="dt">Leaf</span>                                         <span class="ot">-&gt;</span> <span class="dt">Leaf</span>
<span class="ot">&gt;</span>   <span class="dt">Node</span> _ <span class="dt">Leaf</span> n <span class="dt">Leaf</span>                           <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="dv">1</span> <span class="dt">Leaf</span> n <span class="dt">Leaf</span>
<span class="ot">&gt;</span>   <span class="dt">Node</span> _ l<span class="fu">@</span>(<span class="dt">Node</span> h _ _ _)  n  <span class="dt">Leaf</span>             <span class="ot">-&gt;</span> <span class="dt">Node</span> (h<span class="fu">+</span><span class="dv">1</span>) l n <span class="dt">Leaf</span>
<span class="ot">&gt;</span>   <span class="dt">Node</span> _ <span class="dt">Leaf</span>              n r<span class="fu">@</span>(<span class="dt">Node</span> h _ _ _)  <span class="ot">-&gt;</span> <span class="dt">Node</span> (h<span class="fu">+</span><span class="dv">1</span>) <span class="dt">Leaf</span> n r
<span class="ot">&gt;</span>   <span class="dt">Node</span> _ l<span class="fu">@</span>(<span class="dt">Node</span> hl _ _ _) n r<span class="fu">@</span>(<span class="dt">Node</span> hr _ _ _) <span class="ot">-&gt;</span> <span class="dt">Node</span> h' l n r <span class="kw">where</span>
<span class="ot">&gt;</span>     h' <span class="fu">|</span> hl <span class="fu">&lt;</span> hr   <span class="fu">=</span> hr <span class="fu">+</span> <span class="dv">1</span>
<span class="ot">&gt;</span>        <span class="fu">|</span> otherwise <span class="fu">=</span> hl <span class="fu">+</span> <span class="dv">1</span>
<span class="ot">&gt;</span> <span class="ot">{-# INLINE updateHeight #-}</span></code></pre>
<p>That’s all for AVL tree to have <code>insert</code> and <code>member</code> function. For testing, a function to check the balance:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; isBalanced ::</span> <span class="dt">AVL</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> isBalanced t <span class="fu">=</span> <span class="kw">case</span> t <span class="kw">of</span>
<span class="ot">&gt;</span>   <span class="dt">Leaf</span>         <span class="ot">-&gt;</span> <span class="dt">True</span>
<span class="ot">&gt;</span>   <span class="dt">Node</span> h l _ r <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>     abs (h <span class="fu">-</span> height l) <span class="fu">&lt;=</span> <span class="dv">1</span> <span class="fu">&amp;&amp;</span> abs (h <span class="fu">-</span> height r) <span class="fu">&lt;=</span> <span class="dv">1</span> <span class="fu">&amp;&amp;</span>
<span class="ot">&gt;</span>     isBalanced l <span class="fu">&amp;&amp;</span> isBalanced r
<span class="ot">&gt;</span> <span class="ot">{-# INLINE isBalanced #-}</span></code></pre>
<p>Simple check:</p>
<pre><code>ghci&gt; isBalanced $ foldr insert empty [1..1024]
True
ghci&gt; isBalanced $ foldr insert empty [1024,1023..1]
True</code></pre>
<p>Benchmarks:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">NFData</span> (<span class="dt">AVL</span> a) <span class="kw">where</span>
<span class="ot">&gt;</span>   rnf <span class="dt">Leaf</span> <span class="fu">=</span> ()
<span class="ot">&gt;</span>   rnf (<span class="dt">Node</span> h l x r) <span class="fu">=</span> rnf h <span class="ot">`seq`</span> rnf l <span class="ot">`seq`</span> rnf x <span class="ot">`seq`</span> rnf r
<span class="ot">&gt;</span> 
<span class="ot">&gt; avlBenches ::</span> [<span class="dt">Benchmark</span>]
<span class="ot">&gt;</span> avlBenches <span class="fu">=</span>
<span class="ot">&gt;</span>   <span class="kw">let</span> tn n <span class="fu">=</span> foldr insert empty [<span class="dv">0</span><span class="fu">..</span>n<span class="fu">-</span><span class="dv">1</span><span class="ot">::</span><span class="dt">Int</span>]
<span class="ot">&gt;</span>       insertAVL <span class="fu">!</span>k <span class="fu">=</span>
<span class="ot">&gt;</span>         <span class="kw">let</span> <span class="fu">!</span>x <span class="fu">=</span> <span class="kw">let</span> x' <span class="fu">=</span> tn k <span class="kw">in</span> x' <span class="ot">`deepseq`</span> x'
<span class="ot">&gt;</span>         <span class="kw">in</span>  bench (<span class="st">&quot;n=&quot;</span> <span class="fu">++</span> show k) (whnfIO <span class="fu">$</span> insertRand x (<span class="dv">0</span>,k<span class="fu">-</span><span class="dv">1</span>))
<span class="ot">&gt;</span>       insertRand t (a,b) <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>         x <span class="ot">&lt;-</span> getStdRandom (randomR (a,b))
<span class="ot">&gt;</span>         <span class="kw">let</span> y <span class="fu">=</span> insert x t
<span class="ot">&gt;</span>         return <span class="fu">$!</span> y
<span class="ot">&gt;</span>       memberAVL k <span class="fu">=</span>
<span class="ot">&gt;</span>         <span class="kw">let</span> x <span class="fu">=</span> tn k
<span class="ot">&gt;</span>         <span class="kw">in</span>  x <span class="ot">`deepseq`</span> bench (<span class="st">&quot;n=&quot;</span> <span class="fu">++</span> show k) (whnfIO <span class="fu">$</span> memberRand x (<span class="dv">0</span>,k<span class="fu">-</span><span class="dv">1</span>))
<span class="ot">&gt;</span>       memberRand t (a,b) <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>         x <span class="ot">&lt;-</span> getStdRandom (randomR (a,b))
<span class="ot">&gt;</span>         <span class="kw">let</span> y <span class="fu">=</span> member x t
<span class="ot">&gt;</span>         return <span class="fu">$!</span> y
<span class="ot">&gt;</span>       mn n <span class="fu">=</span> <span class="kw">let</span> xs <span class="fu">=</span> [<span class="dv">0</span><span class="fu">..</span>n<span class="fu">-</span><span class="dv">1</span><span class="ot">::</span><span class="dt">Int</span>] <span class="kw">in</span> M.fromList <span class="fu">$</span> zip xs (repeat ())
<span class="ot">&gt;</span>       insertMap <span class="fu">!</span>k <span class="fu">=</span>
<span class="ot">&gt;</span>         <span class="kw">let</span> <span class="fu">!</span>x <span class="fu">=</span> <span class="kw">let</span> x' <span class="fu">=</span> mn k <span class="kw">in</span> x' <span class="ot">`deepseq`</span> x'
<span class="ot">&gt;</span>         <span class="kw">in</span>  bench (<span class="st">&quot;n=&quot;</span> <span class="fu">++</span> show k) (whnfIO <span class="fu">$</span> insertRandM x (<span class="dv">0</span>,k<span class="fu">-</span><span class="dv">1</span>))
<span class="ot">&gt;</span>       insertRandM m (a,b) <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>         x <span class="ot">&lt;-</span> getStdRandom (randomR (a,b))
<span class="ot">&gt;</span>         <span class="kw">let</span> y <span class="fu">=</span> M.insert x () m
<span class="ot">&gt;</span>         return <span class="fu">$!</span> y
<span class="ot">&gt;</span>       memberMap k <span class="fu">=</span>
<span class="ot">&gt;</span>         <span class="kw">let</span> <span class="fu">!</span>x <span class="fu">=</span> <span class="kw">let</span> x' <span class="fu">=</span> mn k <span class="kw">in</span> x' <span class="ot">`deepseq`</span> x'
<span class="ot">&gt;</span>         <span class="kw">in</span>  bench (<span class="st">&quot;n=&quot;</span> <span class="fu">++</span> show k) (whnfIO <span class="fu">$</span> memberRandM x (<span class="dv">0</span>,k<span class="fu">-</span><span class="dv">1</span>))
<span class="ot">&gt;</span>       memberRandM m (a,b) <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>         x <span class="ot">&lt;-</span> getStdRandom (randomR (a,b))
<span class="ot">&gt;</span>         <span class="kw">let</span> y <span class="fu">=</span> M.member x m
<span class="ot">&gt;</span>         return <span class="fu">$!</span> y
<span class="ot">&gt;</span>       benchmarks <span class="fu">=</span>
<span class="ot">&gt;</span>         [ bgroup <span class="st">&quot;AVL&quot;</span>
<span class="ot">&gt;</span>           [ bgroup <span class="st">&quot;insert&quot;</span> [insertAVL (<span class="dv">2</span><span class="fu">^</span>k) <span class="fu">|</span> k <span class="ot">&lt;-</span> [<span class="dv">10</span><span class="fu">..</span><span class="dv">14</span><span class="ot">::</span><span class="dt">Int</span>]]
<span class="ot">&gt;</span>           , bgroup <span class="st">&quot;member&quot;</span> [memberAVL (<span class="dv">2</span><span class="fu">^</span>k) <span class="fu">|</span> k <span class="ot">&lt;-</span> [<span class="dv">10</span><span class="fu">..</span><span class="dv">14</span><span class="ot">::</span><span class="dt">Int</span>]]
<span class="ot">&gt;</span>           ]
<span class="ot">&gt;</span>         , bgroup <span class="st">&quot;Data.Map&quot;</span>
<span class="ot">&gt;</span>           [ bgroup <span class="st">&quot;insert&quot;</span> [insertMap (<span class="dv">2</span><span class="fu">^</span>k) <span class="fu">|</span> k <span class="ot">&lt;-</span> [<span class="dv">10</span><span class="fu">..</span><span class="dv">14</span><span class="ot">::</span><span class="dt">Int</span>]]
<span class="ot">&gt;</span>           , bgroup <span class="st">&quot;member&quot;</span> [memberMap (<span class="dv">2</span><span class="fu">^</span>k) <span class="fu">|</span> k <span class="ot">&lt;-</span> [<span class="dv">10</span><span class="fu">..</span><span class="dv">14</span><span class="ot">::</span><span class="dt">Int</span>]]
<span class="ot">&gt;</span>           ]
<span class="ot">&gt;</span>         ]
<span class="ot">&gt;</span>   <span class="kw">in</span>  benchmarks</code></pre>
<p>Using above benchmark as main:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; main ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main <span class="fu">=</span> defaultMain avlBenches</code></pre>
<p>Compile, run the benchmark, and see the result in html report:</p>
<pre><code>$ ghc -O2 -fllvm AVL.lhs -main-is AVL -o AVL
$ ./AVL -o bench.html</code></pre>
<p>Report is <a href="../static/bench-avl-insert-member.html">here</a>.</p>
<p>Lessons learned: from above simple implementation, a data structure with performance close to those provided by standard package could be implemented. Benchmark show that AVL tree insertion was slightly slower than insertion in Data.Map, performance of member lookup was almost identical. Though when there is no need for making own implemntation, just use the implementation from proven package, in most case those provided data structures has more features, Data.Map.Map has useful functions like <code>insetWith</code>, <code>unionWith</code>, etc.</p>
<p>By the way, during the benchmark I was using <code>nfIO</code> instead of <code>whnfIO</code> for a while, resulting to linearly increasing insertion time for while.</p>
</div>

      </div>
      <div id="footer">
        <div id="footer_content">
          <p>
            <a href="../index.html">Home</a> |
            <a href="../archive.html">Archive</a> |
            <a href="../rss.xml">RSS</a>
          </p>
          Site contents licensed under
          <a href="http://creativecommons.org/licenses/by/3.0/">
            CC Attribution 3.0
          </a>
        </div>
      </div>
    </div>
  </body>
</html>
