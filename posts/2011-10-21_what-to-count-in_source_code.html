<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>8c6794b6.github.io - What to count in source code</title>
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
    <link rel="icon" href="favicon.ico" type="image/ico">
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <link rel="stylesheet" type="text/css" href="../css/hk-tango.css">
    <link rel="alternate" type="application/rss+xml" title="8c6794b6" href="../rss.xml">
  </head>
  <body>
    <div>
      <div id="header">
        <div id="header_contents">
          <div id="header_left">
            <a href="../">8c6794b6.github.io</a>
          </div>
          <div id="navigation">
            <a href="../index.html">Home</a>
            <a href="../archive.html">Archive</a>
            <a href="../rss.xml">RSS</a>
          </div>
        </div>
      </div>

      <div id="content">

        <h1>What to count in source code</h1>
<div id="post_date">
  <strong>October 21, 2011</strong>
</div>

<div id="post_body">
<p>Below is a sample arc code:</p>
<pre><code> | (defop said req
 |   (aform [onlink &quot;click here&quot; (pr &quot;you said: &quot; (arg _ &quot;foo&quot;))]
 |     (input &quot;foo&quot;)
 |     (submit)))</code></pre>
<p>In an article <a href="http://paulgraham.com/arcchallenge.html">arc challenge</a>, Paul Graham was counting size of codetree of arc program. He counted above arc program as 21 nodes: 14 leaves + 7 interior.</p>
<p>How can we count the size of haskell codetree?</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import</span> Control.Monad
<span class="ot">&gt;</span> <span class="kw">import</span> Data.Generics
<span class="ot">&gt;</span> <span class="kw">import</span> Data.Tree
<span class="ot">&gt;</span> <span class="kw">import</span> System.Environment (getArgs)</code></pre>
<p>We could use other module than Language.Haskell.Syntax. e.g. Language.Haskell.Exts from haskell-src-exts.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span> Language.Haskell.Parser
<span class="ot">&gt;</span> <span class="kw">import</span> Language.Haskell.Syntax</code></pre>
<p>This code could be run from command line. Parses the contents and count the number of codesize in all given file paths.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; main ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main <span class="fu">=</span>  getArgs <span class="fu">&gt;&gt;=</span> mapM_ (readFile <span class="fu">&gt;=&gt;</span> count namesAndLits)</code></pre>
<p>Below is arc expression written with Tree data type. Last node “submit” has a child element with empty string, since it was parenthesized explicitly.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; arc ::</span> <span class="dt">Tree</span> <span class="dt">String</span>
<span class="ot">&gt;</span> arc <span class="fu">=</span>
<span class="ot">&gt;</span>   <span class="dt">Node</span> <span class="st">&quot;defop&quot;</span>
<span class="ot">&gt;</span>     [<span class="dt">Node</span> <span class="st">&quot;said&quot;</span> []
<span class="ot">&gt;</span>     ,<span class="dt">Node</span> <span class="st">&quot;req&quot;</span> []
<span class="ot">&gt;</span>     ,<span class="dt">Node</span> <span class="st">&quot;aform&quot;</span>
<span class="ot">&gt;</span>       [<span class="dt">Node</span> <span class="st">&quot;onlink&quot;</span>
<span class="ot">&gt;</span>         [<span class="dt">Node</span> <span class="st">&quot;click here&quot;</span> []
<span class="ot">&gt;</span>         ,<span class="dt">Node</span> <span class="st">&quot;pr&quot;</span>
<span class="ot">&gt;</span>           [<span class="dt">Node</span> <span class="st">&quot;you said: &quot;</span> []
<span class="ot">&gt;</span>           ,<span class="dt">Node</span> <span class="st">&quot;arg&quot;</span>
<span class="ot">&gt;</span>             [<span class="dt">Node</span> <span class="st">&quot;_&quot;</span> []
<span class="ot">&gt;</span>             ,<span class="dt">Node</span> <span class="st">&quot;foo&quot;</span> []]]]
<span class="ot">&gt;</span>         ,<span class="dt">Node</span> <span class="st">&quot;input&quot;</span>
<span class="ot">&gt;</span>           [<span class="dt">Node</span> <span class="st">&quot;foo&quot;</span> []]
<span class="ot">&gt;</span>         ,<span class="dt">Node</span> <span class="st">&quot;submit&quot;</span>
<span class="ot">&gt;</span>           [<span class="dt">Node</span> <span class="st">&quot;&quot;</span> []]]]</code></pre>
<p>Viewing this expression:</p>
<pre><code>| *Main&gt; putStrLn $ drawTree arc
| defop
| |
| +- said
| |
| +- req
| |
| `- aform
|    |
|    +- onlink
|    |  |
|    |  +- click here
|    |  |
|    |  `- pr
|    |     |
|    |     +- you said:
|    |     |
|    |     `- arg
|    |        |
|    |        +- _
|    |        |
|    |        `- foo
|    |
|    +- input
|    |  |
|    |  `- foo
|    |
|    `- submit
|       |
|       `-</code></pre>
<p>To count number of leaves:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; numLeaf ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> numLeaf <span class="fu">=</span> length <span class="fu">.</span> flatten</code></pre>
<p>And number of interior nodes:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; numInterior ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> numInterior t <span class="fu">=</span> <span class="kw">case</span> t <span class="kw">of</span>
<span class="ot">&gt;</span>   <span class="dt">Node</span> _ [] <span class="ot">-&gt;</span> <span class="dv">0</span>
<span class="ot">&gt;</span>   <span class="dt">Node</span> _ xs <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">+</span> sum (map numInterior xs)</code></pre>
<p>And getting the sum:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; countArc ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> countArc t <span class="fu">=</span> numLeaf t <span class="fu">+</span> numInterior t</code></pre>
<p>Number of expression is:</p>
<pre><code>| *Main&gt; countArc arc
| 22</code></pre>
<p>It’s 22, not 21, due to the addition of extra empty node in the end.</p>
<p>So, that was how we can count expression of lisp. Then how to count like for haskell expression? One way is to count occurance of specific data types found in Language.Haskell.Syntax module. When we found HsName datatype in source code, increase the number of codesize by 1. Below is the definition of HsName.</p>
<pre><code>| data HsName = HsIdent String | HsSymbol String</code></pre>
<p>Since most data types in Language.Haskell.Syntax are defined as instance of Data and Typeable, we can use generic functions.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; anyName ::</span> <span class="dt">HsName</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> anyName _ <span class="fu">=</span> <span class="dv">1</span></code></pre>
<p>Traversing over module:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; names ::</span> <span class="dt">HsModule</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> names <span class="fu">=</span> everything (<span class="fu">+</span>) (<span class="dv">0</span> <span class="ot">`mkQ`</span> anyName)</code></pre>
<p>Worker for parsing contents of source code, and applying the counter function.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; count ::</span> (<span class="dt">HsModule</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> count f code <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   <span class="kw">case</span> parseModule code <span class="kw">of</span>
<span class="ot">&gt;</span>     <span class="dt">ParseOk</span> mdl<span class="fu">@</span>(<span class="dt">HsModule</span> _ name _ _ _) <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>       putStrLn <span class="fu">$</span> unwords [show <span class="fu">$</span> f mdl, <span class="st">&quot;\t&quot;</span>, show name]
<span class="ot">&gt;</span>     <span class="dt">ParseFailed</span> loc err <span class="ot">-&gt;</span> print loc <span class="fu">&gt;&gt;</span> putStrLn err</code></pre>
<p>Try it:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; sample1 ::</span> <span class="dt">String</span>
<span class="ot">&gt;</span> sample1 <span class="fu">=</span> <span class="st">&quot;x = 100&quot;</span></code></pre>
<pre><code>| *Main&gt; count names sample1
| 2        Module &quot;Main&quot;</code></pre>
<p>Seems like working. How about another expression?</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; sample2 ::</span> <span class="dt">String</span>
<span class="ot">&gt;</span> sample2 <span class="fu">=</span> <span class="st">&quot;x = 100 + 2&quot;</span></code></pre>
<p>Outputs:</p>
<pre><code>| *Main&gt; count names sample2
| 3        Module &quot;Main&quot;</code></pre>
<p>Why above codesize counted as 3? Not 4, code size of sample1 + 2?</p>
<p>We should have missed some data type to count. For second try, counting HsLiteral and HsName.</p>
<pre><code>| data HsLiteral
|   = HsChar Char
|   | HsString String
|   | HsInt Integer
|   | HsFrac Rational
|   | HsCharPrim Char
|   | HsStringPrim String
|   | HsIntPrim Integer
|   | HsFloatPrim Rational
|   | HsDoublePrim Rational</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; anyLiteral ::</span> <span class="dt">HsLiteral</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> anyLiteral _ <span class="fu">=</span> <span class="dv">1</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; namesAndLits ::</span> <span class="dt">HsModule</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> namesAndLits <span class="fu">=</span> everything (<span class="fu">+</span>) (const <span class="dv">0</span> <span class="ot">`extQ`</span> anyName <span class="ot">`extQ`</span> anyLiteral)</code></pre>
<p>Trying again:</p>
<pre><code>| *Main&gt; count namesAndLits sample1
| 3        Module &quot;Main&quot;
| *Main&gt; count namesAndLits sample2
| 5        Module &quot;Main&quot;</code></pre>
<p>Getting better, but this is counting leaves only.</p>
<p>Since all haskell expression in general is a function that takes single argument, and giving back another function, every expression other than constant value has child element. I’m not sure what we should count as interior node in expression.</p>
</div>

<div class="post_tags">
  <strong>Tags: </strong><a href="../tags/haskell.html">haskell</a>, <a href="../tags/arc.html">arc</a>
</div>


      </div>
      <div id="footer">
        <div id="footer_content">
          <p>
            <a href="../index.html">Home</a> |
            <a href="../archive.html">Archive</a> |
            <a href="../rss.xml">RSS</a>
          </p>

          Site contents licensed under
          <a href="http://creativecommons.org/licenses/by/3.0/">
            CC Attribution 3.0
          </a>
        </div>
      </div>
    </div>
  </body>
</html>
