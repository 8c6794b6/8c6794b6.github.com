<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>8c6794b6.github.com - Guard, case, and pattern match</title>
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
    <link rel="icon" href="favicon.ico" type="image/ico">
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <link rel="stylesheet" type="text/css" href="../css/hk-tango.css">
    <link rel="alternate" type="application/rss+xml" title="8c6794b6" href="../rss.xml">
  </head>
  <body>
    <div>
      <div id="header">
        <div id="header_contents">
          <div id="header_left">
            <a href="../">8c6794b6.github.com</a>
          </div>
          <div id="navigation">
            <a href="../index.html">Home</a>
            <a href="../archive.html">Archive</a>
            <a href="../rss.xml">RSS</a>
          </div>
        </div>
      </div>

      <div id="content">

        <h1>Guard, case, and pattern match</h1>
<div id="post_date">
  <strong>May 27, 2012</strong>
</div>

<div id="post_body">
<p>I tend to use case with tuples when a function takes more than one arguments. Alternate to tupling, we can write with guards or, with direct pattern match in function arguments.</p>
<p>What differences we can find in compiled result?</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">{-# LANGUAGE BangPatterns #-}</span><br />&gt; <span class="kw">module</span> <span class="dt">GuardCasePatmatch</span> <span class="kw">where</span><br />&gt; <br />&gt; <span class="kw">import</span> <span class="dt">Criterion.Main</span><br />&gt; <span class="kw">import</span> <span class="dt">Data.Int</span></code></pre>
<p>Target function is, naive power function. First, with guard:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">pow_guard </span><span class="ot">::</span> <span class="dt">Int64</span> <span class="ot">-&gt;</span> <span class="dt">Int64</span> <span class="ot">-&gt;</span> <span class="dt">Int64</span><br />&gt; pow_guard <span class="fu">!</span>a <span class="fu">!</span>b<br />&gt;   <span class="fu">|</span> b <span class="fu">==</span> <span class="dv">0</span>    <span class="fu">=</span> <span class="dv">1</span><br />&gt;   <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> a <span class="fu">*</span> pow_guard a (b<span class="fu">-</span><span class="dv">1</span>)</code></pre>
<p>Next, tupled case:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">pow_case </span><span class="ot">::</span> <span class="dt">Int64</span> <span class="ot">-&gt;</span> <span class="dt">Int64</span> <span class="ot">-&gt;</span> <span class="dt">Int64</span><br />&gt; pow_case <span class="fu">!</span>a <span class="fu">!</span>b <span class="fu">=</span> <span class="kw">case</span> (a,b) <span class="kw">of</span><br />&gt;   (_,<span class="dv">0</span>) <span class="ot">-&gt;</span> <span class="dv">1</span><br />&gt;   _     <span class="ot">-&gt;</span> a <span class="fu">*</span> pow_case a (b<span class="fu">-</span><span class="dv">1</span>)</code></pre>
<p>Last, pattern match</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">pow_patmatch </span><span class="ot">::</span> <span class="dt">Int64</span> <span class="ot">-&gt;</span> <span class="dt">Int64</span> <span class="ot">-&gt;</span> <span class="dt">Int64</span><br />&gt; pow_patmatch <span class="fu">!</span>a <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span><br />&gt; pow_patmatch <span class="fu">!</span>a <span class="fu">!</span>b <span class="fu">=</span> a <span class="fu">*</span> pow_patmatch a (b<span class="fu">-</span><span class="dv">1</span>)</code></pre>
<p>Testing that all three give same result:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">test </span><span class="ot">::</span> <span class="dt">Bool</span><br />&gt; test <span class="fu">=</span> <span class="fu">all</span> <span class="fu">id</span> [f x y <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">32</span>], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">32</span>]] <span class="kw">where</span><br />&gt;   f a b <span class="fu">=</span><br />&gt;     <span class="kw">let</span> pc <span class="fu">=</span> pow_case a b<br />&gt;         pg <span class="fu">=</span> pow_guard a b<br />&gt;         pp <span class="fu">=</span> pow_patmatch a b<br />&gt;     <span class="kw">in</span>  pc <span class="fu">==</span> pg <span class="fu">&amp;&amp;</span> pg <span class="fu">==</span> pp</code></pre>
<p>Result:</p>
<pre><code>ghci&gt; test
True
</code></pre>
<p>Seems fine. Now benchmarking:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">main </span><span class="ot">::</span> <span class="dt">IO</span> ()<br />&gt; main <span class="fu">=</span> defaultMain<br />&gt;  [ bench <span class="st">&quot;guard&quot;</span> (nf (pow_guard <span class="dv">2</span>) <span class="dv">64</span>)<br />&gt;  , bench <span class="st">&quot;case&quot;</span> (nf (pow_case <span class="dv">2</span>) <span class="dv">64</span>)<br />&gt;  , bench <span class="st">&quot;patmatch&quot;</span> (nf (pow_patmatch <span class="dv">2</span>) <span class="dv">64</span>)<br />&gt;  ]</code></pre>
<p>Compile and run:</p>
<pre><code>$ ghc --numeric-version
7.4.1
$ ghc -fllvm -optl-O3 -O3 -o a.out -main-is GuardCasePatmatch gcp.lhs
</code></pre>
<p>Result:</p>
<pre><code>benchmarking guard
mean: 386.1059 ns, lb 385.6170 ns, ub 386.6460 ns, ci 0.950
std dev: 2.640960 ns, lb 2.261563 ns, ub 3.111325 ns, ci 0.950

benchmarking case
mean: 382.4345 ns, lb 382.0820 ns, ub 382.8864 ns, ci 0.950
std dev: 2.030602 ns, lb 1.667205 ns, ub 2.567343 ns, ci 0.950

benchmarking patmatch
mean: 385.1643 ns, lb 384.6979 ns, ub 385.7441 ns, ci 0.950
std dev: 2.657997 ns, lb 2.163594 ns, ub 3.363755 ns, ci 0.950
</code></pre>
<p>Almost same. How about dumped core?</p>
<p>Exerpt of dumped core of <code>power_guard</code> looks like this:</p>
<pre><code>Rec {
GuardCasePatmatch.$wpow_guard [Occ=LoopBreaker]
  :: GHC.Prim.Int# -&gt; GHC.Prim.Int# -&gt; GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=DmdType LL]
GuardCasePatmatch.$wpow_guard =
  \ (ww_s2qq :: GHC.Prim.Int#) (ww1_s2qu :: GHC.Prim.Int#) -&gt;
    case ww1_s2qu of wild_X1r {
      __DEFAULT -&gt;
        case GuardCasePatmatch.$wpow_guard ww_s2qq (GHC.Prim.-# wild_X1r 1)
        of ww2_s2qy { __DEFAULT -&gt;
        GHC.Prim.*# ww_s2qq ww2_s2qy
        };
      0 -&gt; 1
    }
end Rec }

...

GuardCasePatmatch.pow_guard =
  \ (w_s2qo :: GHC.Int.Int64) (w1_s2qs :: GHC.Int.Int64) -&gt;
    case w_s2qo of _ { GHC.Int.I64# ww_s2qq -&gt;
    case w1_s2qs of _ { GHC.Int.I64# ww1_s2qu -&gt;
    case GuardCasePatmatch.$wpow_guard ww_s2qq ww1_s2qu
    of ww2_s2qy { __DEFAULT -&gt;
    GHC.Int.I64# ww2_s2qy
    }
    }
    }
</code></pre>
<p>Dumped core of <code>power_case</code>:</p>
<pre><code>Rec {
GuardCasePatmatch.$wpow_case [Occ=LoopBreaker]
  :: GHC.Prim.Int# -&gt; GHC.Prim.Int# -&gt; GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=DmdType LL]
GuardCasePatmatch.$wpow_case =
  \ (ww_s2qc :: GHC.Prim.Int#) (ww1_s2qg :: GHC.Prim.Int#) -&gt;
    case ww1_s2qg of wild_X1n {
      __DEFAULT -&gt;
        case GuardCasePatmatch.$wpow_case ww_s2qc (GHC.Prim.-# wild_X1n 1)
        of ww2_s2qk { __DEFAULT -&gt;
        GHC.Prim.*# ww_s2qc ww2_s2qk
        };
      0 -&gt; 1
    }
end Rec }

...

GuardCasePatmatch.pow_case =
  \ (w_s2qa :: GHC.Int.Int64) (w1_s2qe :: GHC.Int.Int64) -&gt;
    case w_s2qa of _ { GHC.Int.I64# ww_s2qc -&gt;
    case w1_s2qe of _ { GHC.Int.I64# ww1_s2qg -&gt;
    case GuardCasePatmatch.$wpow_case ww_s2qc ww1_s2qg
    of ww2_s2qk { __DEFAULT -&gt;
    GHC.Int.I64# ww2_s2qk
    }
    }
    }
</code></pre>
<p>And dumped core of <code>pow_patmatch</code>:</p>
<pre><code>Rec {
GuardCasePatmatch.$wpow_patmatch [Occ=LoopBreaker]
  :: GHC.Prim.Int# -&gt; GHC.Prim.Int# -&gt; GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=DmdType LL]
GuardCasePatmatch.$wpow_patmatch =
  \ (ww_s2qE :: GHC.Prim.Int#) (ww1_s2qI :: GHC.Prim.Int#) -&gt;
    case ww1_s2qI of wild_X1t {
      __DEFAULT -&gt;
        case GuardCasePatmatch.$wpow_patmatch
               ww_s2qE (GHC.Prim.-# wild_X1t 1)
        of ww2_s2qM { __DEFAULT -&gt;
        GHC.Prim.*# ww_s2qE ww2_s2qM
        };
      0 -&gt; 1
    }
end Rec }

...

GuardCasePatmatch.pow_patmatch =
  \ (w_s2qC :: GHC.Int.Int64) (w1_s2qG :: GHC.Int.Int64) -&gt;
    case w_s2qC of _ { GHC.Int.I64# ww_s2qE -&gt;
    case w1_s2qG of _ { GHC.Int.I64# ww1_s2qI -&gt;
    case GuardCasePatmatch.$wpow_patmatch ww_s2qE ww1_s2qI
    of ww2_s2qM { __DEFAULT -&gt;
    GHC.Int.I64# ww2_s2qM
    }
    }
    }
</code></pre>
<p>No difference other than bounded names.</p>
</div>

<div class="post_tags">
  <strong>Tags: </strong><a href="../tags/haskell.html">haskell</a>, <a href="../tags/performance.html">performance</a>, <a href="../tags/ghc.html">ghc</a>
</div>


      </div>
      <div id="footer">
        <div id="footer_content">
          <p>
            <a href="../index.html">Home</a> |
            <a href="../archive.html">Archive</a> |
            <a href="../rss.xml">RSS</a>
          </p>

          Site contents licensed under
          <a href="http://creativecommons.org/licenses/by/3.0/">
            CC Attribution 3.0
          </a>
        </div>
      </div>
    </div>
  </body>
</html>
